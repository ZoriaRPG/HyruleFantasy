//std_shortcuts.zh
//Shortcuts for ZScript Functions that ignore *-> namespaces, and classes.
//v0.8.5
//2nd October, 2017

//Class FFC

//Namespace Link

bool InputStart() {return Link->InputStart;}
bool InputMap() {return Link->InputMap;}
bool InputUp() {return Link->InputUp;}
bool InputDown() {return Link->InputDown;}
bool InputLeft() {return Link->InputLeft;}
bool InputRight() {return Link->InputRight;}
bool InputA() {return Link->InputA;}
bool InputB() {return Link->InputB;}
bool InputL() {return Link->InputL;}
bool InputR() {return Link->InputR;}
bool InputEx1() {return Link->InputEx1;}
bool InputEx2() {return Link->InputEx2;}
bool InputEx3() {return Link->InputEx3;}
bool InputEx4() {return Link->InputEx4;}
bool InputAxisUp() {return Link->InputAxisUp;}
bool InputAxisDown() {return Link->InputAxisDown;}
bool InputAxisLeft() {return Link->InputAxisLeft;}
bool InputAxisRight() {return Link->InputAxisRight;}
bool PressStart() {return Link->PressStart;}
bool PressMap() {return Link->PressMap;}
bool PressUp() {return Link->PressUp;}
bool PressDown() {return Link->PressDown;}
bool PressLeft() {return Link->PressLeft;}
bool PressRight() {return Link->PressRight;}
bool PressA() {return Link->PressA;}
bool PressB() {return Link->PressB;}
bool PressL() {return Link->PressL;}
bool PressR() {return Link->PressR;}
bool PressEx1() {return Link->PressEx1;}
bool PressEx2() {return Link->PressEx2;}
bool PressEx3() {return Link->PressEx3;}
bool PressEx4() {return Link->PressEx4;}
bool PressAxisUp() {return Link->PressAxisUp;}
bool PressAxisDown() {return Link->PressAxisDown;}
bool PressAxisLeft() {return Link->PressAxisLeft;}
bool PressAxisRight() {return Link->PressAxisRight;}

int InputMouseX() {return Link->InputMouseX;}
int InputMouseY() {return Link->InputMouseY;}
int InputMouseB() {return Link->InputMouseB;}
int InputMouseZ() {return Link->InputMouseZ;}

void InputStart(bool val) { Link->InputStart = val;}
void InputMap(bool val) { Link->InputMap = val;}
void InputUp(bool val) { Link->InputUp = val;}
void InputDown(bool val) { Link->InputDown = val;}
void InputLeft(bool val) { Link->InputLeft = val;}
void InputRight(bool val) { Link->InputRight = val;}
void InputA(bool val) { Link->InputA = val;}
void InputB(bool val) { Link->InputB = val;}
void InputL(bool val) { Link->InputL = val;}
void InputR(bool val) { Link->InputR = val;}
void InputEx1(bool val) { Link->InputEx1 = val;}
void InputEx2(bool val) { Link->InputEx2 = val;}
void InputEx3(bool val) { Link->InputEx3 = val;}
void InputEx4(bool val) { Link->InputEx4 = val;}
void InputAxisUp(bool val) { Link->InputAxisUp = val;}
void InputAxisDown(bool val) { Link->InputAxisDown = val;}
void InputAxisLeft(bool val) { Link->InputAxisLeft = val;}
void InputAxisRight(bool val) { Link->InputAxisRight = val;}
void PressStart(bool val) { Link->PressStart = val;}
void PressMap(bool val) { Link->PressMap = val;}
void PressUp(bool val) { Link->PressUp = val;}
void PressDown(bool val) { Link->PressDown = val;}
void PressLeft(bool val) { Link->PressLeft = val;}
void PressRight(bool val) { Link->PressRight = val;}
void PressA(bool val) { Link->PressA = val;}
void PressB(bool val) { Link->PressB = val;}
void PressL(bool val) { Link->PressL = val;}
void PressR(bool val) { Link->PressR = val;}
void PressEx1(bool val) { Link->PressEx1 = val;}
void PressEx2(bool val) { Link->PressEx2 = val;}
void PressEx3(bool val) { Link->PressEx3 = val;}
void PressEx4(bool val) { Link->PressEx4 = val;}
void PressAxisUp(bool val) { Link->PressAxisUp = val;}
void PressAxisDown(bool val) { Link->PressAxisDown = val;}
void PressAxisLeft(bool val) { Link->PressAxisLeft = val;}
void PressAxisRight(bool val) { Link->PressAxisRight = val;}

void InputMouseX(int val) { Link->InputMouseX = val;}
void InputMouseY(int val) { Link->InputMouseY = val;}
void InputMouseB(int val) { Link->InputMouseB = val;}
void InputMouseZ(int val) { Link->InputMouseZ = val;}


//Link Functions

void Warp(int dmap, int screen){
	Link->Warp(dmap,screen);
}


void PitWarp(int dmap, int screen){
	Link->PitWarp(dmap,screen);
}

//Namespace Game Functions


int GetCurScreen(){
	return Game->GetCurScreen();
}

int GetCurDMap(){
	return Game->GetCurDMap();
}

int GetCurMap(){ 
	return Game->GetCurMap();
}

int GetCurDMapScreen(){
	return Game->GetCurDMapScreen();
}

int GetCurLevel(){
	return Game->GetCurLevel();
}


int NumDeaths(){
	return Game->NumDeaths;
}

void NumDeaths(int num){
	Game->NumDeaths = num;
}

int GameCheat(){
	return Game->Cheat;
}

void GameCheat(int cheatLevel){
	Game->Cheat = cheatLevel;
}

int GameTime(){
	return Game->Time;
}

void GameTime(int t){
	Game->Time = t;
}

bool TimeValid(){
	return Game->TimeValid;
}

void TimeValid(bool t){
	Game->TimeValid = t;
}

bool HasPlayed(){
	return Game->HasPlayed;
}

void HasPlayed(bool a){
	Game->HasPlayed = a;
}

bool Standalone(){
	return Game->Standalone;
}

int ContinueDMap(){
	return Game->ContinueDMap;
}

void ContinueDMap(int dmap){
	Game->ContinueDMap = dmap;
}

int ContinueScreen(){
	return Game->ContinueScreen;
}

void ContinueScreen(int scr){
	Game->ContinueScreen = scr;
}

int LastEntranceDMap(){
	return Game->LastEntranceDMap;
}

void LastEntranceDMap(int dmap){
	Game->LastEntranceDMap = dmap;
}

int LastEntranceScreen(){
	return Game->LastEntranceScreen;
}

void LastEntranceScreen(int scr){
	Game->LastEntranceScreen = scr;
}

int NumHeartPieces(){
	return Game->Generic[GEN_HEARTPIECES];
}

void NumHeartPieces(int num){
	Game->Generic[GEN_HEARTPIECES] = num;
}

void NumHeartPieces(int num, bool increase){
	Game->Generic[GEN_HEARTPIECES] += num;
}

int MagicDrainRate(){
	return Game->Generic[GEN_MAGICDRAINRATE] ;
}

void MagicDrainRate(int amount){
	Game->Generic[GEN_MAGICDRAINRATE] = amount;
}

int CanSlash(){
	return Game->Generic[GEN_CANSLASH];
}

void CanSlash(bool canSlash){
	if ( canSlash ) {
		Game->Generic[GEN_CANSLASH] = 1;
	}
	else {
		Game->Generic[GEN_CANSLASH] = 0;
	}
}

int WarpLevel(){
	return Game->Generic[GEN_WARPLEVEL];
}

void WarpLevel(int warpSpot){
	Game->Generic[GEN_WARPLEVEL] = warpSpot;
}

int HeartPiecesPerHC(){
	return Game->Generic[GEN_HCPPERHC];
}

void HeartPiecesPerHC(int num){
	Game->Generic[GEN_HCPPERHC] = num;
}

int ContinueHearts(){
	return Game->Generic[GEN_CONTINUEHEARTS];
}

void ContinueHearts(int hearts){
	Game->Generic[GEN_CONTINUEHEARTS] = hearts;
}

int ContinueIsPercent(){
	return Game->Generic[GEN_CONTINUEISPERCENT];
}

void ContinueIsPercent(int perc){
	Game->Generic[GEN_CONTINUEISPERCENT] = perc;
}

bool GetComboD(int pos, int comboID){
	if ( Screen->ComboD[pos] == comboID ) return true;
	return false;
}

bool GetComboT(int pos, int type){
	if ( Screen->ComboT[pos] == type ) return true;
	return false;
}

bool GetComboF(int pos, int flag){
	if ( Screen->ComboF[pos] == flag ) return true;
	return false;
}

bool GetComboI(int pos, int inhFlag){
	if ( Screen->ComboI[pos] == inhFlag ) return true;
	return false;
}

bool GetComboC(int pos, int cset, int check){
	if ( Screen->ComboC[pos] == cset ) return true;
	return false;
}

bool GetComboS(int pos, int solidity){
	if ( Screen->ComboS[pos] == solidity ) return true;
	return false;
}

void SetComboD(int pos, int comboID){
	Screen->ComboD[pos] = comboID;
}

void SetComboT(int pos, int type){
	Screen->ComboT[pos] = type;
}

void SetComboF(int pos, int flag){
	Screen->ComboF[pos] = flag;
}

void SetComboI(int pos, int inhFlag){
	Screen->ComboI[pos] = inhFlag;
}

void SetComboC(int pos, int cset){
	Screen->ComboC[pos] = cset;
}

void SetComboS(int pos, int solidity){
	Screen->ComboS[pos] = solidity;
}

void TriggerSecrets(bool triggered){
	Screen->TriggerSecrets();
}

void TriggerSecrets(int state){
	Screen->State[ST_SECRET] = state;
	Screen->TriggerSecrets();
}

void SetSideWarp(int warp, int screen, int dmap, int type){
	Screen->SetSideWarp(warp, screen, dmap, type);
}

void SetTileWarp(int warp, int screen, int dmap, int type){
	Screen->SetTileWarp(warp, screen, dmap, type);
}


void GetSideWarpDMap(int warp){
	Screen->GetSideWarpDMap(warp);
}

void GetSideWarpScreen(int warp){
	Screen->GetSideWarpScreen(warp);
}


void GetSideWarpType(int warp){
	Screen-> GetSideWarpType(warp);
}

void GetTileWarpDMap(int warp){
	Screen->GetTileWarpDMap(warp);
}

void GetTileWarpScreen(int warp){
	Screen->GetTileWarpScreen(warp);
}

void GetTileWarpType(int warp){
	Screen->GetTileWarpType(warp);
}

int LayerMap(int n){
	return Screen->LayerMap(n);
}

int LayerScreen(int n){
	return Screen->LayerScreen(n);
}

int NumItems(){
	return Screen->NumItems();
}

void LoadItem(int itm){
	Screen->LoadItem(itm);
}

void CreateItem(int id){
	Screen->CreateItem(id);
}

ffc LoadFFC(int num){
	return Screen->LoadFFC(num);
}

int NumNPCs(){
	return Screen->NumNPCs();
}

void LoadNPC(int num){
	Screen->LoadNPC(num);
}

void CreateNPC(int id){
	Screen->CreateNPC(id);
}

int NumLWeapons(){
	return Screen->NumLWeapons();
}

void LoadLWeapon(int num){
	Screen->LoadLWeapon(num);
}

void CreateLWeapon(int type){
	Screen->CreateLWeapon(type);
}

int NumEWeapons(){
	return Screen->NumEWeapons();
}

void LoadEWeapon(int num){
	Screen->LoadEWeapon(num);
}

void CreateEWeapon(int type){
	Screen->CreateEWeapon(type);
}

bool isSolid(int x, int y){
	return Screen->isSolid(x,y);
}

void ClearSprites(int spritelist){
	Screen->ClearSprites(spritelist);
}

//Drawing

void Rectangle(int layer, int x, int y, int x2, int y2, int color, float scale, int rx, int ry, int rangle, bool fill, int opacity){
	Screen->Rectangle(layer, x, y, x2, y2, color, scale, rx, ry, rangle, fill, opacity);
}

void Circle(int layer, int x, int y, int radius, int color, float scale, int rx, int ry, int rangle, bool fill, int opacity){
	Screen->Circle(layer, x, y, radius, color, scale, rx, ry, rangle, fill, opacity);
}

void Arc(int layer, int x, int y, int radius, int startangle, int endangle, int color, float scale, int rx, int ry, int rangle, bool closed, bool fill, int opacity){
	Screen->Arc(layer, x, y, radius, startangle, endangle, color, scale, rx, ry, rangle, closed, fill, opacity);
}

void Ellipse(int layer, int x, int y, int xradius, int yradius, int color, float scale, int rx, int ry, int rangle, bool fill, int opacity){
	Screen->Ellipse(layer, x, y, xradius, yradius, color, scale, rx, ry, rangle, fill, opacity);
}

void Spline(int layer, int x1, int y1, int x2, int y2, int x3, int y3,int x4, int y4, int color, int opacity){
	Screen->Spline(layer, x1, y1, x2, y2, x3, y3, x4, y4, color, opacity);
}

void Line(int layer, int x, int y, int x2, int y2, int color, float scale, int rx, int ry, int rangle, int opacity){
	Screen->Line(layer, x, y, x2, y2, color, scale, rx, ry, rangle, opacity);
}

void PutPixel(int layer, int x, int y, int color, int rx, int ry, int rangle, int opacity){
	Screen->PutPixel(layer, x, y, color, rx, ry, rangle, opacity);
}

void DrawTile(int layer, int x, int y, int tile, int blockw, int blockh, int cset, int xscale, int yscale, int rx, int ry, int rangle, int flip, bool transparency, int opacity){
	Screen->DrawTile(layer, x, y, tile, blockw, blockh, cset, xscale, yscale, rx, ry, rangle, flip, transparency, opacity);
}

